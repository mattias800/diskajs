<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Diska by mattias800</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Diska</h1>
        <h2>A dependency injection framework for Javascript, inspired by Guice by Google.</h2>
        <a href="https://github.com/mattias800/diskajs" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="diska" class="anchor" href="#diska" aria-hidden="true"><span class="octicon octicon-link"></span></a>diska</h1>

<p>A lightweight DI framework in Javascript, inspired by Guice by Google.</p>

<h2>
<a id="information-on-babel-6" class="anchor" href="#information-on-babel-6" aria-hidden="true"><span class="octicon octicon-link"></span></a>Information on Babel 6</h2>

<p>Babel 6 doesn't support decorators, which is an important part of diska.
If you use Babel 6 to compile your code, you can still use diska without decorators.</p>

<p>The distributed version of diska (in NPM) is compiled with Babel 5 until this is resolved by the Babel team.</p>

<p>There is a plugin for Babel 6 that adds support for decorators, but we haven't tried it.
<a href="https://www.npmjs.com/package/babel-plugin-transform-decorators-legacy">https://www.npmjs.com/package/babel-plugin-transform-decorators-legacy</a></p>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h2>

<pre><code>npm install diskajs --save-dev
</code></pre>

<h2>
<a id="compatibility" class="anchor" href="#compatibility" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compatibility</h2>

<ul>
<li>Babel 5.x (all features)</li>
<li>Babel 6.x (no decorators)</li>
<li>Node</li>
<li>React Native 0.15 (all features, uses Babel 5)</li>
<li>React Native 0.16 (no decorators, uses Babel 6)</li>
</ul>

<h2>
<a id="example-code" class="anchor" href="#example-code" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example code</h2>

<p>The tests contain a lot of sample code. They test all features of diska.</p>

<p>You can find most of them here:
<a href="https://github.com/mattias800/diskajs/blob/master/test/di/InjectorSpec.js">https://github.com/mattias800/diskajs/blob/master/test/di/InjectorSpec.js</a></p>

<p>You can also check out this repository to see how to setup diska with Node or React Native:</p>

<p><a href="https://github.com/mattias800/diskajs-examples">https://github.com/mattias800/diskajs-examples</a></p>

<p>These have not been updated in a while though, and do not use decorators.
Also, they were made for an older version of React Native where Webpack was required for diska to work.
You can use diska in React Native projects without Webpack now.</p>

<h2>
<a id="dependency-injection" class="anchor" href="#dependency-injection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependency injection</h2>

<p>To learn how dependency injection and Guice works, please see the Guice documentation.
All diska documentation assumes that you have previous experience with Guice and DI.
While this is not a clone of Guice, it is inspired by it and anyone who has used Guice
will be instantly familiar with diska.</p>

<h2>
<a id="tutorial" class="anchor" href="#tutorial" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tutorial</h2>

<p>First things first; To start injecting, you need an injector.
And to get an injector, you need a module that defines what to inject.</p>

<p>Let's start with an empty module.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> <span class="pl-smi">UserFactory</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>./UserFactory<span class="pl-pds">"</span></span>;
<span class="pl-k">const</span> <span class="pl-c1">module</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-k">const</span> <span class="pl-c1">injector</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Injector</span>(<span class="pl-c1">module</span>);
<span class="pl-k">const</span> userFactory<span class="pl-k">:</span><span class="pl-c1">UserFactory</span> <span class="pl-k">=</span> <span class="pl-smi">injector</span>.<span class="pl-en">get</span>(UserFactory);</pre></div>

<p>This should give you an instance of UserFactory.</p>

<h4>
<a id="but-what-does-the-userfactory-look-like" class="anchor" href="#but-what-does-the-userfactory-look-like" aria-hidden="true"><span class="octicon octicon-link"></span></a>But what does the UserFactory look like?</h4>

<p>All classes that are instantiated by diska must either</p>

<ol>
<li>Be decorated with <code>@Inject()</code> or</li>
<li>have a <code>static inject()</code> method that returns a list of types to be injected.</li>
</ol>

<p><code>UserFactory</code> can look like this:</p>

<div class="highlight highlight-source-js"><pre>@<span class="pl-en">Inject</span>()
<span class="pl-k">export</span> <span class="pl-v">default</span> <span class="pl-k">class</span> <span class="pl-en">UserFactory</span> {

  <span class="pl-en">createUser</span>() {
    <span class="pl-k">return</span> {};
  }  

}</pre></div>

<p>The <code>@Inject()</code> decorator tells diska that this class can be instantiated, and has no dependencies. 
It creates the instance by running the constructor with no arguments.</p>

<h4>
<a id="what-if-we-cant-use-decorators" class="anchor" href="#what-if-we-cant-use-decorators" aria-hidden="true"><span class="octicon octicon-link"></span></a>What if we can't use decorators?</h4>

<p>Use <code>static inject()</code> instead. It is a method that must return a list of dependency types.
If there are no dependencies, it should just return an empty list.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-v">default</span> <span class="pl-k">class</span> <span class="pl-en">UserFactory</span> {

  <span class="pl-k">static</span> <span class="pl-en">inject</span>() {
    <span class="pl-k">return</span> [];     
  }

  <span class="pl-en">createUser</span>() {
    <span class="pl-k">return</span> {};
  }

}</pre></div>

<h4>
<a id="but-how-do-i-add-a-dependency" class="anchor" href="#but-how-do-i-add-a-dependency" aria-hidden="true"><span class="octicon octicon-link"></span></a>But how do I add a dependency?</h4>

<p>To add a dependency, import it, add it to <code>@Inject</code> parameters and add a constructor argument.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> <span class="pl-smi">UserDecorator</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>./UserDecorator<span class="pl-pds">"</span></span>;
<span class="pl-k">import</span> {<span class="pl-smi">Inject</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>diskajs<span class="pl-pds">"</span></span>;

@<span class="pl-en">Inject</span>(UserDecorator)
<span class="pl-k">export</span> <span class="pl-v">default</span> <span class="pl-k">class</span> <span class="pl-en">UserFactory</span> {

  userDecorator<span class="pl-k">:</span>UserDecorator;

  <span class="pl-en">constructor</span>(<span class="pl-smi">userDecorator</span>:<span class="pl-smi">UserDecorator</span>) {
    <span class="pl-v">this</span>.<span class="pl-smi">userDecorator</span> <span class="pl-k">=</span> userDecorator;
  }

  <span class="pl-en">createUser</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-smi">userDecorator</span>.<span class="pl-en">decorate</span>({});
  }

}</pre></div>

<p>If you cannot use decorators, add the dependency to the list returned by <code>static inject()</code>.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">static</span> <span class="pl-en">inject</span>() {
  <span class="pl-k">return</span> [UserDecorator];     
}</pre></div>

<p>Now when diska tries to create an instance, it finds that it needs a <code>UserDecorator</code> instance, 
so it creates an instance of it in the same way it is trying to create an instance of <code>UserDecorator</code>.</p>

<h4>
<a id="what-if-you-have-more-than-one-dependency" class="anchor" href="#what-if-you-have-more-than-one-dependency" aria-hidden="true"><span class="octicon octicon-link"></span></a>What if you have more than one dependency?</h4>

<p>Just add more to the <code>@Inject(...)</code> decoration.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> <span class="pl-smi">UserDecorator</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>./UserDecorator<span class="pl-pds">"</span></span>;
<span class="pl-k">import</span> {<span class="pl-smi">Inject</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>diskajs<span class="pl-pds">"</span></span>;

@<span class="pl-en">Inject</span>(UserDecorator, UserTransformer)
<span class="pl-k">export</span> <span class="pl-v">default</span> <span class="pl-k">class</span> <span class="pl-en">UserFactory</span> {

  userDecorator<span class="pl-k">:</span>UserDecorator;
  userTransformer<span class="pl-k">:</span>UserTransformer;

  <span class="pl-en">constructor</span>(<span class="pl-smi">userDecorator</span>:<span class="pl-smi">UserDecorator</span>,
              <span class="pl-smi">userTransformer</span>:<span class="pl-smi">UserTransformer</span>) {
    <span class="pl-v">this</span>.<span class="pl-smi">userDecorator</span> <span class="pl-k">=</span> userDecorator;
    <span class="pl-v">this</span>.<span class="pl-smi">userTransformer</span> <span class="pl-k">=</span> userTransformer;
  }

  <span class="pl-en">createUser</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-smi">userDecorator</span>.<span class="pl-en">decorate</span>({});
  }

}</pre></div>

<p>The injected dependency instances are passed to the constructor in the same order as they are 
specified in the <code>@Inject()</code> decoration.
In this case, the <code>UserDecorator</code> instance will be passed as first argument, and <code>UserTransformer</code> as the second argument.</p>

<p>If any of these classes have dependencies, diska will try to instantiate them as well.
This is repeated recursively until it has created all dependencies in the object tree, or until it reaches a dependency 
that it cannot create, in which case an exception is thrown.</p>

<h4>
<a id="what-if-we-have-a-mock-version-of-userfactory-that-we-want-to-use-in-our-tests" class="anchor" href="#what-if-we-have-a-mock-version-of-userfactory-that-we-want-to-use-in-our-tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>What if we have a mock version of <code>UserFactory</code> that we want to use in our tests?</h4>

<p>You can bind another type to it. Setup a new module that is used just for tests (are that specific test).</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">module</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-smi">module</span>.<span class="pl-en">bind</span>(UserFactory).<span class="pl-en">to</span>(MockedUserFactory);
<span class="pl-k">const</span> <span class="pl-c1">injector</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Injector</span>(<span class="pl-c1">module</span>);
<span class="pl-k">const</span> userFactory<span class="pl-k">:</span><span class="pl-c1">UserFactory</span> <span class="pl-k">=</span> <span class="pl-smi">injector</span>.<span class="pl-en">get</span>(UserFactory);</pre></div>

<h4>
<a id="what-if-we-want-the-userfactory-to-be-a-singleton-so-that-we-reuse-it-instead-of-creating-new-instances-all-the-time" class="anchor" href="#what-if-we-want-the-userfactory-to-be-a-singleton-so-that-we-reuse-it-instead-of-creating-new-instances-all-the-time" aria-hidden="true"><span class="octicon octicon-link"></span></a>What if we want the <code>UserFactory</code> to be a singleton, so that we reuse it instead of creating new instances all the time?</h4>

<p>Add <code>@Singleton()</code> to the class.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> <span class="pl-smi">UserDecorator</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>./UserDecorator<span class="pl-pds">"</span></span>;
<span class="pl-k">import</span> {<span class="pl-smi">Inject</span>, <span class="pl-smi">Singleton</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>diskajs<span class="pl-pds">"</span></span>;

@<span class="pl-en">Inject</span>(UserDecorator)
@<span class="pl-en">Singleton</span>()
<span class="pl-k">export</span> <span class="pl-v">default</span> <span class="pl-k">class</span> <span class="pl-en">UserFactory</span> {

  userDecorator<span class="pl-k">:</span>UserDecorator;

  <span class="pl-en">constructor</span>(<span class="pl-smi">userDecorator</span>:<span class="pl-smi">UserDecorator</span>) {
    <span class="pl-v">this</span>.<span class="pl-smi">userDecorator</span> <span class="pl-k">=</span> userDecorator;
  }

  <span class="pl-en">createUser</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-smi">userDecorator</span>.<span class="pl-en">decorate</span>({});
  }

}</pre></div>

<h4>
<a id="what-if-we-want-to-declare-it-as-singleton-in-the-binding-instead-of-forcing-the-class-to-always-be-a-singleton" class="anchor" href="#what-if-we-want-to-declare-it-as-singleton-in-the-binding-instead-of-forcing-the-class-to-always-be-a-singleton" aria-hidden="true"><span class="octicon octicon-link"></span></a>What if we want to declare it as singleton in the binding, instead of forcing the class to always be a singleton?</h4>

<p>Just add <code>.asSingleton()</code> to the binding.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">module</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-smi">module</span>.<span class="pl-en">bind</span>(UserFactory).<span class="pl-en">to</span>(UserFactory).<span class="pl-en">asSingleton</span>();
<span class="pl-k">const</span> <span class="pl-c1">injector</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Injector</span>(<span class="pl-c1">module</span>);
<span class="pl-k">const</span> userFactory<span class="pl-k">:</span><span class="pl-c1">UserFactory</span> <span class="pl-k">=</span> <span class="pl-smi">injector</span>.<span class="pl-en">get</span>(UserFactory);</pre></div>

<h4>
<a id="es5" class="anchor" href="#es5" aria-hidden="true"><span class="octicon octicon-link"></span></a>ES5</h4>

<p>If you are running ES5, you don't have classes. 
Instead, you can use functions and set the <code>inject</code> property on the function.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> Grinder <span class="pl-k">=</span> <span class="pl-c1">require</span>(<span class="pl-s"><span class="pl-pds">'</span>./Grinder<span class="pl-pds">'</span></span>);

<span class="pl-k">function</span> <span class="pl-en">CoffeeMaker</span>(<span class="pl-smi">grinder</span>) {

  <span class="pl-v">this</span>.<span class="pl-smi">grinder</span> <span class="pl-k">=</span> grinder;

  <span class="pl-v">this</span>.<span class="pl-smi">brew</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
    <span class="pl-v">this</span>.<span class="pl-smi">grinder</span>.<span class="pl-en">grind</span>();
    <span class="pl-k">return</span> <span class="pl-s"><span class="pl-pds">'</span>brew<span class="pl-pds">'</span></span>;
  }

}

<span class="pl-c1">CoffeeMaker</span>.<span class="pl-en">inject</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {
  <span class="pl-k">return</span> [Grinder];
}</pre></div>

<h3>
<a id="modules" class="anchor" href="#modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Modules</h3>

<p>A module is a configuration that defines what the injector should inject.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">module</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-smi">module</span>.<span class="pl-en">bind</span>(Grinder).<span class="pl-en">to</span>(Grinder);
<span class="pl-smi">module</span>.<span class="pl-en">bind</span>(CoffeeMaker).<span class="pl-en">to</span>(CoffeeMaker);
<span class="pl-k">const</span> <span class="pl-c1">injector</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Injector</span>(<span class="pl-c1">module</span>);
<span class="pl-k">const</span> <span class="pl-c1">coffeeMaker</span> <span class="pl-k">=</span> <span class="pl-smi">injector</span>.<span class="pl-en">get</span>(CoffeeMaker);
<span class="pl-smi">coffeeMaker</span>.<span class="pl-en">brew</span>();</pre></div>

<p>In this example we only have one type of Grinder and CoffeeMaker.
Binding a class to itself is optional and we can remove them.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">const</span> <span class="pl-c1">module</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-k">const</span> <span class="pl-c1">injector</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Injector</span>(<span class="pl-c1">module</span>);
<span class="pl-k">const</span> <span class="pl-c1">coffeeMaker</span> <span class="pl-k">=</span> <span class="pl-smi">injector</span>.<span class="pl-en">get</span>(CoffeeMaker);
<span class="pl-smi">coffeeMaker</span>.<span class="pl-en">brew</span>();</pre></div>

<p>When there is no binding for that type in th emodul and we try to inject <code>CoffeeMaker</code>, 
it will just inject an instance of <code>CoffeeMaker</code>.</p>

<h4>
<a id="using-multiple-modules" class="anchor" href="#using-multiple-modules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Using multiple modules</h4>

<p>The injector constructor can take multiple arguments where all arguments are modules, 
or one argument that is an array of modules.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// One argument that is an array of modules</span>
<span class="pl-k">const</span> <span class="pl-c1">module1</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-k">const</span> <span class="pl-c1">module2</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-k">const</span> <span class="pl-c1">injector</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Injector</span>([module1, module2]);</pre></div>

<div class="highlight highlight-source-js"><pre><span class="pl-c">// Several arguments that are all modules</span>
<span class="pl-k">const</span> <span class="pl-c1">module1</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-k">const</span> <span class="pl-c1">module2</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-k">const</span> <span class="pl-c1">injector</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Injector</span>(module1, module2);</pre></div>

<p>If multiple modules contain binding for the same type, the binding of the first module
in the array or arguments will be used.</p>

<h4>
<a id="unit-tests" class="anchor" href="#unit-tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>Unit tests</h4>

<p>When testing, you typically create a separate testing module that is used to create instances in your tests.
The injector that is created with that module can then be imported in your test code and used to create instances.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> {<span class="pl-smi">testInjector</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>path/to/testInjector<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">ArrayUtil</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>path/to/ArrayUtil<span class="pl-pds">'</span></span>;

<span class="pl-k">const</span> arrayUtil<span class="pl-k">:</span><span class="pl-c1">ArrayUtil</span> <span class="pl-k">=</span> <span class="pl-smi">testInjector</span>.<span class="pl-en">get</span>(ArrayUtil);

<span class="pl-en">describe</span>(<span class="pl-s"><span class="pl-pds">"</span>ArrayUtil<span class="pl-pds">"</span></span>, () <span class="pl-k">=&gt;</span> {
  <span class="pl-en">it</span>(<span class="pl-s"><span class="pl-pds">"</span>should ...<span class="pl-pds">"</span></span>, () <span class="pl-k">=&gt;</span> {
    <span class="pl-c">// expect()...</span>
  });
});</pre></div>

<p>If a test requires something specific for that test only, you can create a local module, and a child injector with that module.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> {<span class="pl-smi">Injector</span>, <span class="pl-smi">Module</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>diskajs<span class="pl-pds">"</span></span>;

<span class="pl-k">import</span> {<span class="pl-smi">testInjector</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>path/to/testInjector<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">ArrayUtil</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>path/to/ArrayUtil<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> <span class="pl-smi">ArrayUtilMock</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>path/to/ArrayUtilMock<span class="pl-pds">'</span></span>;

<span class="pl-k">const</span> <span class="pl-c1">localModule</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-smi">module</span>.<span class="pl-en">bind</span>(ArrayUtil).<span class="pl-en">to</span>(ArrayUtilMock);

<span class="pl-k">const</span> <span class="pl-c1">localInjector</span> <span class="pl-k">=</span> <span class="pl-smi">testInjector</span>.<span class="pl-en">getChildInjector</span>(localModule);

<span class="pl-k">const</span> arrayUtil<span class="pl-k">:</span><span class="pl-c1">ArrayUtil</span> <span class="pl-k">=</span> <span class="pl-smi">localInjector</span>.<span class="pl-en">get</span>(ArrayUtil);

<span class="pl-c">// arrayUtil is an ArrayUtilMock instance</span>

<span class="pl-en">describe</span>(<span class="pl-s"><span class="pl-pds">"</span>ArrayUtil<span class="pl-pds">"</span></span>, () <span class="pl-k">=&gt;</span> {
  <span class="pl-en">it</span>(<span class="pl-s"><span class="pl-pds">"</span>should ...<span class="pl-pds">"</span></span>, () <span class="pl-k">=&gt;</span> {
    <span class="pl-c">// expect()...</span>
  });
});</pre></div>

<p>More on child injectors further down.</p>

<h3>
<a id="providers" class="anchor" href="#providers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Providers</h3>

<p>If the class we are trying to inject lacks an <code>@Inject()</code> decoration (or <code>static inject()</code>), the injector
won't know how to instantiate a class. It will fail with an exception.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">export</span> <span class="pl-k">class</span> <span class="pl-en">Wheel</span> {

  <span class="pl-en">constructor</span>(<span class="pl-smi">material</span>) {
    <span class="pl-v">this</span>.<span class="pl-smi">material</span> <span class="pl-k">=</span> material;
  }

}</pre></div>

<p>You can supply the module with a provider for <code>Wheel</code>. The provider must extend the <code>Provider</code> class in diska.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> {<span class="pl-smi">Provider</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>diskajs<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> {<span class="pl-smi">Wheel</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>./Wheel<span class="pl-pds">'</span></span>;

<span class="pl-k">export</span> <span class="pl-k">class</span> <span class="pl-en">WheelProvider</span> <span class="pl-k">extends</span> <span class="pl-en">Provider</span> {

  <span class="pl-en">get</span>() {
    <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-en">Wheel</span>({ type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>iron<span class="pl-pds">'</span></span> });
  }

}</pre></div>

<p>This way we delegate the responsibility of instantiating the class to the provider, and diska will 
instantiate <code>WheelProvider</code> and run <code>get()</code> to get the Wheel instance.</p>

<h4>
<a id="providers-can-have-dependencies" class="anchor" href="#providers-can-have-dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Providers can have dependencies</h4>

<p>If you want, you can add an <code>@Inject()</code> (or <code>static inject()</code>) to your provider and these dependencies will be injected.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">import</span> {<span class="pl-smi">Provider</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>diskajs<span class="pl-pds">'</span></span>;
<span class="pl-k">import</span> {<span class="pl-smi">SomeDependency</span>} <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>./SomeDependency<span class="pl-pds">'</span></span>;

@<span class="pl-en">Inject</span>(SomeDependency)
<span class="pl-k">export</span> <span class="pl-k">class</span> <span class="pl-en">SomeProvider</span> <span class="pl-k">extends</span> <span class="pl-en">Provider</span> {

  someDependency<span class="pl-k">:</span>SomeDependency;

  <span class="pl-en">constructor</span>(<span class="pl-smi">someDependency</span>:<span class="pl-smi">SomeDependency</span>) {
    <span class="pl-v">super</span>();
    <span class="pl-v">this</span>.<span class="pl-smi">someDependency</span> <span class="pl-k">=</span> someDependency;
  }

  <span class="pl-en">get</span>() {
    <span class="pl-k">return</span> <span class="pl-v">this</span>.<span class="pl-smi">someDependency</span>.<span class="pl-en">createAwesomeStuff</span>();
  }

}</pre></div>

<h3>
<a id="singletons" class="anchor" href="#singletons" aria-hidden="true"><span class="octicon octicon-link"></span></a>Singletons</h3>

<p>Some objects, such as services and transformers, should be reused and only instantiated once.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">module</span>.<span class="pl-en">bind</span>(UserService).<span class="pl-en">to</span>(UserServiceRestApi).<span class="pl-en">asSingleton</span>();</pre></div>

<p><code>UserServiceRestApi</code> will be instantiated the first time it is injected, 
and after that, whenever a class needs a <code>UserService</code>, that instance of the
<code>UserServiceRestApi</code> object will be injected.</p>

<p>You can also decorate the <code>UserService</code> or <code>UserServiceRestApi</code> class with <code>@Singleton()</code>.</p>

<h4>
<a id="singletons-and-providers" class="anchor" href="#singletons-and-providers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Singletons and providers</h4>

<p>You can use providers to instantiate singletons as well.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-smi">module</span>.<span class="pl-en">bind</span>(UserService).<span class="pl-en">toProvider</span>(UserServiceProvider).<span class="pl-en">asSingleton</span>();</pre></div>

<p>When a class depends on a <code>UserService</code> the <code>UserServiceProvider</code> will be
instantiated, <code>get()</code> will be called and the returned object will be reused
whenever any other class depends on <code>UserService</code>.
The provider will only be instantiated once, and <code>get()</code> will only be called once.</p>

<h3>
<a id="child-injectors" class="anchor" href="#child-injectors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Child injectors</h3>

<p>diska supports child injectors.
You can get a child injector from an injector by calling <code>injector.getChildInjector()</code> with one or more modules 
for the child injector as argument.</p>

<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> <span class="pl-c1">module</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-smi">module</span>.<span class="pl-en">bind</span>(GlobalService).<span class="pl-en">toProvider</span>(GlobalServiceProvider).<span class="pl-en">asSingleton</span>();
<span class="pl-k">var</span> injector <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Injector</span>(<span class="pl-c1">module</span>);
<span class="pl-k">var</span> childModule <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Module</span>();
<span class="pl-smi">childModule</span>.<span class="pl-en">bind</span>(LocalService).<span class="pl-en">toProvider</span>(LocalServiceProvider);
<span class="pl-k">var</span> childInjector <span class="pl-k">=</span> <span class="pl-smi">injector</span>.<span class="pl-en">getChildInjector</span>(childModule);
<span class="pl-k">var</span> service <span class="pl-k">=</span> <span class="pl-smi">childInjector</span>.<span class="pl-en">get</span>(LocalService);
<span class="pl-k">var</span> error <span class="pl-k">=</span> <span class="pl-smi">injector</span>.<span class="pl-en">get</span>(LocalService); <span class="pl-c">// Throws exception</span></pre></div>

<p>Modules added to the child injectors will not be added to the parent injector.</p>

<p>The bindings in the child injector module are derived from the parent injector module and the parent 
injector is not changed in any way.</p>

<p>If the binding already exists in the parent, it is overridden for the child injector.</p>

<h2>
<a id="running-the-tests" class="anchor" href="#running-the-tests" aria-hidden="true"><span class="octicon octicon-link"></span></a>Running the tests</h2>

<pre><code>npm test
</code></pre>

<p>If you have Wallaby, you can open the project in IntelliJ and start Wallaby.</p>

<h2>
<a id="issues" class="anchor" href="#issues" aria-hidden="true"><span class="octicon octicon-link"></span></a>Issues</h2>

<p>Did you find any issues? Did you fix a bug?
Please create a ticket or send a pull request.</p>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/mattias800/diskajs/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/mattias800/diskajs/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/mattias800/diskajs"></a> is maintained by <a href="https://github.com/mattias800">mattias800</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-71474931-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
