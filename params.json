{"name":"Diska","tagline":"A dependency injection framework for Javascript, inspired by Guice by Google.","body":"# diska\r\n\r\nA lightweight DI framework in Javascript, inspired by Guice by Google.\r\n\r\n## Information on Babel 6\r\n\r\nBabel 6 doesn't support decorators, which is an important part of diska.\r\nIf you use Babel 6 to compile your code, you can still use diska without decorators.\r\n\r\nThe distributed version of diska (in NPM) is compiled with Babel 5 until this is resolved by the Babel team.\r\n \r\nThere is a plugin for Babel 6 that adds support for decorators, but we haven't tried it.\r\nhttps://www.npmjs.com/package/babel-plugin-transform-decorators-legacy\r\n\r\n## Installation\r\n\r\n```\r\nnpm install diskajs --save-dev\r\n```\r\n\r\n## Compatibility\r\n\r\n* Babel 5.x (all features)\r\n* Babel 6.x (no decorators)\r\n* Node\r\n* React Native 0.15 (all features, uses Babel 5)\r\n* React Native 0.16 (no decorators, uses Babel 6)\r\n\r\n## Example code\r\n\r\nThe tests contain a lot of sample code. They test all features of diska.\r\n\r\nYou can find most of them here:\r\nhttps://github.com/mattias800/diskajs/blob/master/test/di/InjectorSpec.js\r\n\r\nYou can also check out this repository to see how to setup diska with Node or React Native:\r\n\r\nhttps://github.com/mattias800/diskajs-examples\r\n\r\n## Dependency injection\r\n\r\nTo learn how dependency injection and Guice works, please see the Guice documentation.\r\nAll diska documentation assumes that you have previous experience with Guice and DI.\r\nWhile this is not a clone of Guice, it is inspired by it and anyone who has used Guice\r\nwill be instantly familiar with diska.\r\n\r\n## Tutorial\r\n\r\nFirst things first; To start injecting, you need an injector.\r\nAnd to get an injector, you need a module that defines what to inject.\r\n\r\nLet's start with an empty module.\r\n\r\n```js\r\nimport UserFactory from \"./UserFactory\";\r\nconst module = new Module();\r\nconst injector = new Injector(module);\r\nconst userFactory:UserFactory = injector.get(UserFactory);\r\n```\r\n\r\nThis should give you an instance of UserFactory.\r\n\r\n#### But what does the UserFactory look like?\r\n\r\nAll classes that are instantiated by diska must either\r\n\r\n1. Be decorated with `@Inject()` or\r\n2. have a `static inject()` method that returns a list of types to be injected.\r\n\r\n`UserFactory` can look like this:\r\n\r\n```js\r\n@Inject()\r\nexport default class UserFactory {\r\n\r\n\tcreateUser() {\r\n\t\treturn {};\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\nThe `@Inject()` decorator tells diska that this class can be instantiated, and has no dependencies. \r\nIt creates the instance by running the constructor with no arguments.\r\n\r\n#### What if we can't use decorators?\r\n\r\nUse `static inject()` instead. It is a method that must return a list of dependency types.\r\nIf there are no dependencies, it should just return an empty list.\r\n \r\n```js\r\nexport default class UserFactory {\r\n\r\n\tstatic inject() {\r\n\t\treturn [];\t\t \r\n\t}\r\n\t\t \r\n\tcreateUser() {\r\n\t\treturn {};\r\n\t}\r\n}\r\n```\r\n\r\n#### But how do I add a dependency?\r\n\r\nTo add a dependency, import it, add it to `@Inject` parameters and add a constructor argument.\r\n\r\n```js\r\nimport UserDecorator from \"./UserDecorator\";\r\nimport {Inject} from \"diskajs\";\r\n\r\n@Inject(UserDecorator)\r\nexport default class UserFactory {\r\n\r\n\tuserDecorator:UserDecorator;\r\n\t\t\r\n\tconstructor(userDecorator:UserDecorator) {\r\n\t\tthis.userDecorator = userDecorator;\r\n\t}\r\n\t\t\r\n\tcreateUser() {\r\n\t\treturn this.userDecorator.decorate({});\r\n\t}\r\n}\r\n```\r\n\r\nIf you cannot use decorators, add the dependency to the list returned by `static inject()`.\r\n\r\n```js\r\nstatic inject() {\r\n\treturn [UserDecorator];\t\t \r\n}\r\n```\r\n\r\nNow when diska tries to create an instance, it finds that it needs a `UserDecorator` instance, \r\nso it creates an instance of it in the same way it is trying to create an instance of `UserDecorator`.\r\n\r\n#### What if you have more than one dependency?\r\n\r\nJust add more to the `@Inject(...)` decoration.\r\n\r\n```js\r\nimport UserDecorator from \"./UserDecorator\";\r\nimport {Inject} from \"diskajs\";\r\n\r\n@Inject(UserDecorator, UserTransformer)\r\nexport default class UserFactory {\r\n\r\n\tuserDecorator:UserDecorator;\r\n\tuserTransformer:UserTransformer;\r\n\t\t\r\n\tconstructor(userDecorator:UserDecorator,\r\n\t\t\t\t\t\t\tuserTransformer:UserTransformer) {\r\n\t\tthis.userDecorator = userDecorator;\r\n\t\tthis.userTransformer = userTransformer;\r\n\t}\r\n\t\t\r\n\tcreateUser() {\r\n\t\treturn this.userDecorator.decorate({});\r\n\t}\r\n}\r\n```\r\n\r\nThe injected dependency instances are passed to the constructor in the same order as they are \r\nspecified in the `@Inject()` decoration.\r\nIn this case, the `UserDecorator` instance will be passed as first argument, and `UserTransformer` as the second argument.\r\n\r\nIf any of these classes have dependencies, diska will try to instantiate them as well.\r\nThis is repeated recursively until it has created all dependencies in the object tree, or until it reaches a dependency \r\nthat it cannot create, in which case an exception is thrown.\r\n\r\n#### What if we have a mock version of `UserFactory` that we want to use in our tests?\r\n\r\nYou can bind another type to it. Setup a new module that is used just for tests (are that specific test).\r\n\r\n```js\r\nconst module = new Module();\r\nmodule.bind(UserFactory).to(MockedUserFactory);\r\nconst injector = new Injector(module);\r\nconst userFactory:UserFactory = injector.get(UserFactory);\r\n```\r\n\r\n#### What if we want the `UserFactory` to be a singleton, so that we reuse it instead of creating new instances all the time?\r\n\r\nAdd `@Singleton()` to the class.\r\n\r\n```js\r\nimport UserDecorator from \"./UserDecorator\";\r\nimport {Inject, Singleton} from \"diskajs\";\r\n\r\n@Inject(UserDecorator)\r\n@Singleton()\r\nexport default class UserFactory {\r\n\r\n\t\tuserDecorator:UserDecorator;\r\n\t\t\r\n\t\tconstructor(userDecorator:UserDecorator) {\r\n\t\t\t\tthis.userDecorator = userDecorator;\r\n\t\t}\r\n\t\t\r\n    createUser() {\r\n      return this.userDecorator.decorate({});\r\n    }\r\n}\r\n```\r\n\r\n#### What if we want to declare it as singleton in the binding, instead of forcing the class to always be a singleton?\r\n\r\nJust add `.asSingleton()` to the binding.\r\n```js\r\nconst module = new Module();\r\nmodule.bind(UserFactory).to(UserFactory).asSingleton();\r\nconst injector = new Injector(module);\r\nconst userFactory:UserFactory = injector.get(UserFactory);\r\n```\r\n\r\n#### ES5\r\n\r\nIf you are running ES5, you don't have classes. \r\nInstead, you can use functions and set the `inject` property on the function.\r\n\r\n```js\r\nvar Grinder = require('./Grinder');\r\n\r\nfunction CoffeeMaker(grinder) {\r\n\r\n    this.grinder = grinder;\r\n    \r\n    this.brew = function() {\r\n        this.grinder.grind();\r\n        return 'brew';\r\n    }\r\n}\r\n\r\nCoffeeMaker.inject = function() {\r\n    return [Grinder];\r\n}\r\n```\r\n\r\n### Modules\r\n\r\nA module is a configuration that defines what the injector should inject.\r\n\r\n```js\r\nconst module = new Module();\r\nmodule.bind(Grinder).to(Grinder);\r\nmodule.bind(CoffeeMaker).to(CoffeeMaker);\r\nconst injector = new Injector(module);\r\nconst coffeeMaker = injector.get(CoffeeMaker);\r\ncoffeeMaker.brew();\r\n```\r\n\r\nIn this example we only have one type of Grinder and CoffeeMaker.\r\nBinding a class to itself is optional and we can remove them.\r\n\r\n```js\r\nconst module = new Module();\r\nconst injector = new Injector(module);\r\nconst coffeeMaker = injector.get(CoffeeMaker);\r\ncoffeeMaker.brew();\r\n```\r\n\r\nWhen there is no binding for that type in th emodul and we try to inject `CoffeeMaker`, \r\nit will just inject an instance of `CoffeeMaker`.\r\n\r\n#### Using multiple modules\r\n\r\nThe injector constructor can take multiple arguments where all arguments are modules, \r\nor one argument that is an array of modules.\r\n\r\n```js\r\n// One argument that is an array of modules\r\nconst module1 = new Module();\r\nconst module2 = new Module();\r\nconst injector = new Injector([module1, module2]);\r\n```\r\n\r\n```js\r\n// Several arguments that are all modules\r\nconst module1 = new Module();\r\nconst module2 = new Module();\r\nconst injector = new Injector(module1, module2);\r\n```\r\n\r\nIf multiple modules contain binding for the same type, the binding of the first module\r\nin the array or arguments will be used.\r\n\r\n#### Unit tests\r\n\r\nWhen testing, you typically create a separate testing module that is used to create instances in your tests.\r\nThe injector that is created with that module can then be imported in your test code and used to create instances.\r\n\r\n```js\r\nimport {testInjector} from 'path/to/testInjector';\r\nimport ArrayUtil from 'path/to/ArrayUtil';\r\n\r\nconst arrayUtil:ArrayUtil = testInjector.get(ArrayUtil);\r\n\r\ndescribe(\"ArrayUtil\", () => {\r\n\tit(\"should ...\", () => {\r\n\t   // expect()...\r\n\t});\r\n});\r\n```\r\n\r\nIf a test requires something specific for that test only, you can create a local module, and a child injector with that module.\r\n\r\n```js\r\nimport {Injector, Module} from \"diskajs\";\r\n\r\nimport {testInjector} from 'path/to/testInjector';\r\nimport ArrayUtil from 'path/to/ArrayUtil';\r\nimport ArrayUtilMock from 'path/to/ArrayUtilMock';\r\n\r\nconst localModule = new Module();\r\nmodule.bind(ArrayUtil).to(ArrayUtilMock);\r\n\r\nconst localInjector = testInjector.getChildInjector(localModule);\r\n\r\nconst arrayUtil:ArrayUtil = localInjector.get(ArrayUtil);\r\n\r\n// arrayUtil is an ArrayUtilMock instance\r\n\r\ndescribe(\"ArrayUtil\", () => {\r\n\tit(\"should ...\", () => {\r\n\t   // expect()...\r\n\t});\r\n});\r\n```\r\n\r\nMore on child injectors further down.\r\n\r\n### Providers\r\n\r\nIf the class we are trying to inject lacks an `@Inject()` decoration (or `static inject()`), the injector\r\nwon't know how to instantiate a class. It will fail with an exception.\r\n\r\n```js\r\nexport class Wheel {\r\n\r\n    constructor(material) {\r\n        this.material = material;\r\n    }\r\n\r\n}\r\n```\r\n\r\nYou can supply the module with a provider for `Wheel`. The provider must extend the `Provider` class in diska.\r\n\r\n```js\r\nimport {Provider} from 'diskajs';\r\nimport {Wheel} from './Wheel';\r\n\r\nexport class WheelProvider extends Provider {\r\n\r\n    get() {\r\n        return new Wheel({ type: 'iron' });\r\n    }\r\n}\r\n```\r\n\r\nThis way we delegate the responsibility of instantiating the class to the provider, and diska will \r\ninstantiate `WheelProvider` and run `get()` to get the Wheel instance.\r\n\r\n#### Providers can have dependencies\r\n\r\nIf you want, you can add an `@Inject()` (or `static inject()`) to your provider and these dependencies will be injected.\r\n\r\n```js\r\nimport {Provider} from 'diskajs';\r\nimport {SomeDependency} from './SomeDependency';\r\n\r\n@Inject(SomeDependency)\r\nexport class SomeProvider extends Provider {\r\n\r\n\tsomeDependency:SomeDependency;\r\n\t\r\n\tconstructor(someDependency:SomeDependency) {\r\n\t\tsuper();\r\n\t\tthis.someDependency = someDependency;\r\n\t}\r\n\r\n\tget() {\r\n\t\treturn this.someDependency.createAwesomeStuff();\r\n\t}\r\n\r\n}\r\n```\r\n\r\n### Singletons\r\n\r\nSome objects, such as services and transformers, should be reused and only instantiated once.\r\n\r\n```js\r\nmodule.bind(UserService).to(UserServiceRestApi).asSingleton();\r\n```\r\n\r\n`UserServiceRestApi` will be instantiated the first time it is injected, \r\nand after that, whenever a class needs a `UserService`, that instance of the\r\n`UserServiceRestApi` object will be injected.\r\n\r\nYou can also decorate the `UserService` or `UserServiceRestApi` class with `@Singleton()`.\r\n\r\n#### Singletons and providers\r\n\r\nYou can use providers to instantiate singletons as well.\r\n\r\n```js\r\nmodule.bind(UserService).toProvider(UserServiceProvider).asSingleton();\r\n```\r\n\r\nWhen a class depends on a `UserService` the `UserServiceProvider` will be\r\ninstantiated, `get()` will be called and the returned object will be reused\r\nwhenever any other class depends on `UserService`.\r\nThe provider will only be instantiated once, and `get()` will only be called once.\r\n\r\n### Child injectors\r\n\r\ndiska supports child injectors.\r\nYou can get a child injector from an injector by calling `injector.getChildInjector()` with one or more modules \r\nfor the child injector as argument.\r\n\r\n```js\r\nvar module = new Module();\r\nmodule.bind(GlobalService).toProvider(GlobalServiceProvider).asSingleton();\r\nvar injector = new Injector(module);\r\nvar childModule = new Module();\r\nchildModule.bind(LocalService).toProvider(LocalServiceProvider);\r\nvar childInjector = injector.getChildInjector(childModule);\r\nvar service = childInjector.get(LocalService);\r\nvar error = injector.get(LocalService); // Throws exception\r\n```\r\n\r\nModules added to the child injectors will not be added to the parent injector.\r\n\r\nThe bindings in the child injector module are derived from the parent injector module and the parent \r\ninjector is not changed in any way.\r\n\r\nIf the binding already exists in the parent, it is overridden for the child injector.\r\n\r\n## Running the tests\r\n\r\n```\r\nnpm test\r\n```\r\n\r\nIf you have Wallaby, you can open the project in IntelliJ and start Wallaby.\r\n\r\n## Issues\r\n\r\nDid you find any issues? Did you fix a bug?\r\nPlease create a ticket or send a pull request.\r\n","google":"UA-71474931-1","note":"Don't delete this file! It's used internally to help with page regeneration."}